{"ast":null,"code":"import { OpenAIError } from \"../../core/error.mjs\";\n/**\n * Percent-encode everything that isn't safe to have in a path without encoding safe chars.\n *\n * Taken from https://datatracker.ietf.org/doc/html/rfc3986#section-3.3:\n * > unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n * > sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n * > pchar       = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n */\nexport function encodeURIPath(str) {\n  return str.replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);\n}\nexport const createPathTagFunction = (pathEncoder = encodeURIPath) => function path(statics, ...params) {\n  // If there are no params, no processing is needed.\n  if (statics.length === 1) return statics[0];\n  let postPath = false;\n  const path = statics.reduce((previousValue, currentValue, index) => {\n    if (/[?#]/.test(currentValue)) {\n      postPath = true;\n    }\n    return previousValue + currentValue + (index === params.length ? '' : (postPath ? encodeURIComponent : pathEncoder)(String(params[index])));\n  }, '');\n  const pathOnly = path.split(/[?#]/, 1)[0];\n  const invalidSegments = [];\n  const invalidSegmentPattern = /(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)/gi;\n  let match;\n  // Find all invalid segments\n  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {\n    invalidSegments.push({\n      start: match.index,\n      length: match[0].length\n    });\n  }\n  if (invalidSegments.length > 0) {\n    let lastEnd = 0;\n    const underline = invalidSegments.reduce((acc, segment) => {\n      const spaces = ' '.repeat(segment.start - lastEnd);\n      const arrows = '^'.repeat(segment.length);\n      lastEnd = segment.start + segment.length;\n      return acc + spaces + arrows;\n    }, '');\n    throw new OpenAIError(`Path parameters result in path with invalid segments:\\n${path}\\n${underline}`);\n  }\n  return path;\n};\n/**\n * URI-encodes path params and ensures no unsafe /./ or /../ path segments are introduced.\n */\nexport const path = /* @__PURE__ */createPathTagFunction(encodeURIPath);","map":{"version":3,"names":["OpenAIError","encodeURIPath","str","replace","encodeURIComponent","createPathTagFunction","pathEncoder","path","statics","params","length","postPath","reduce","previousValue","currentValue","index","test","String","pathOnly","split","invalidSegments","invalidSegmentPattern","match","exec","push","start","lastEnd","underline","acc","segment","spaces","repeat","arrows"],"sources":["/Users/seungsoohan/LovleChat/frontend/node_modules/openai/src/internal/utils/path.ts"],"sourcesContent":["import { OpenAIError } from '../../core/error';\n\n/**\n * Percent-encode everything that isn't safe to have in a path without encoding safe chars.\n *\n * Taken from https://datatracker.ietf.org/doc/html/rfc3986#section-3.3:\n * > unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n * > sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n * > pchar       = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n */\nexport function encodeURIPath(str: string) {\n  return str.replace(/[^A-Za-z0-9\\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);\n}\n\nexport const createPathTagFunction = (pathEncoder = encodeURIPath) =>\n  function path(statics: readonly string[], ...params: readonly unknown[]): string {\n    // If there are no params, no processing is needed.\n    if (statics.length === 1) return statics[0]!;\n\n    let postPath = false;\n    const path = statics.reduce((previousValue, currentValue, index) => {\n      if (/[?#]/.test(currentValue)) {\n        postPath = true;\n      }\n      return (\n        previousValue +\n        currentValue +\n        (index === params.length ? '' : (postPath ? encodeURIComponent : pathEncoder)(String(params[index])))\n      );\n    }, '');\n\n    const pathOnly = path.split(/[?#]/, 1)[0]!;\n    const invalidSegments = [];\n    const invalidSegmentPattern = /(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)/gi;\n    let match;\n\n    // Find all invalid segments\n    while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {\n      invalidSegments.push({\n        start: match.index,\n        length: match[0].length,\n      });\n    }\n\n    if (invalidSegments.length > 0) {\n      let lastEnd = 0;\n      const underline = invalidSegments.reduce((acc, segment) => {\n        const spaces = ' '.repeat(segment.start - lastEnd);\n        const arrows = '^'.repeat(segment.length);\n        lastEnd = segment.start + segment.length;\n        return acc + spaces + arrows;\n      }, '');\n\n      throw new OpenAIError(`Path parameters result in path with invalid segments:\\n${path}\\n${underline}`);\n    }\n\n    return path;\n  };\n\n/**\n * URI-encodes path params and ensures no unsafe /./ or /../ path segments are introduced.\n */\nexport const path = /* @__PURE__ */ createPathTagFunction(encodeURIPath);\n"],"mappings":"SAASA,WAAW,QAAE;AAEtB;;;;;;;;AAQA,OAAM,SAAUC,aAAaA,CAACC,GAAW;EACvC,OAAOA,GAAG,CAACC,OAAO,CAAC,kCAAkC,EAAEC,kBAAkB,CAAC;AAC5E;AAEA,OAAO,MAAMC,qBAAqB,GAAGA,CAACC,WAAW,GAAGL,aAAa,KAC/D,SAASM,IAAIA,CAACC,OAA0B,EAAE,GAAGC,MAA0B;EACrE;EACA,IAAID,OAAO,CAACE,MAAM,KAAK,CAAC,EAAE,OAAOF,OAAO,CAAC,CAAC,CAAE;EAE5C,IAAIG,QAAQ,GAAG,KAAK;EACpB,MAAMJ,IAAI,GAAGC,OAAO,CAACI,MAAM,CAAC,CAACC,aAAa,EAAEC,YAAY,EAAEC,KAAK,KAAI;IACjE,IAAI,MAAM,CAACC,IAAI,CAACF,YAAY,CAAC,EAAE;MAC7BH,QAAQ,GAAG,IAAI;IACjB;IACA,OACEE,aAAa,GACbC,YAAY,IACXC,KAAK,KAAKN,MAAM,CAACC,MAAM,GAAG,EAAE,GAAG,CAACC,QAAQ,GAAGP,kBAAkB,GAAGE,WAAW,EAAEW,MAAM,CAACR,MAAM,CAACM,KAAK,CAAC,CAAC,CAAC,CAAC;EAEzG,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMG,QAAQ,GAAGX,IAAI,CAACY,KAAK,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC,CAAE;EAC1C,MAAMC,eAAe,GAAG,EAAE;EAC1B,MAAMC,qBAAqB,GAAG,oCAAoC;EAClE,IAAIC,KAAK;EAET;EACA,OAAO,CAACA,KAAK,GAAGD,qBAAqB,CAACE,IAAI,CAACL,QAAQ,CAAC,MAAM,IAAI,EAAE;IAC9DE,eAAe,CAACI,IAAI,CAAC;MACnBC,KAAK,EAAEH,KAAK,CAACP,KAAK;MAClBL,MAAM,EAAEY,KAAK,CAAC,CAAC,CAAC,CAACZ;KAClB,CAAC;EACJ;EAEA,IAAIU,eAAe,CAACV,MAAM,GAAG,CAAC,EAAE;IAC9B,IAAIgB,OAAO,GAAG,CAAC;IACf,MAAMC,SAAS,GAAGP,eAAe,CAACR,MAAM,CAAC,CAACgB,GAAG,EAAEC,OAAO,KAAI;MACxD,MAAMC,MAAM,GAAG,GAAG,CAACC,MAAM,CAACF,OAAO,CAACJ,KAAK,GAAGC,OAAO,CAAC;MAClD,MAAMM,MAAM,GAAG,GAAG,CAACD,MAAM,CAACF,OAAO,CAACnB,MAAM,CAAC;MACzCgB,OAAO,GAAGG,OAAO,CAACJ,KAAK,GAAGI,OAAO,CAACnB,MAAM;MACxC,OAAOkB,GAAG,GAAGE,MAAM,GAAGE,MAAM;IAC9B,CAAC,EAAE,EAAE,CAAC;IAEN,MAAM,IAAIhC,WAAW,CAAC,0DAA0DO,IAAI,KAAKoB,SAAS,EAAE,CAAC;EACvG;EAEA,OAAOpB,IAAI;AACb,CAAC;AAEH;;;AAGA,OAAO,MAAMA,IAAI,GAAG,eAAgBF,qBAAqB,CAACJ,aAAa,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}